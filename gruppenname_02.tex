\documentclass[11pt]{scrartcl}

\usepackage[top=1.5cm]{geometry}
\usepackage{url}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

\newcommand{\youranswerhere}{[Your answer goes here \ldots]}
\renewcommand{\thesubsection}{\arabic{subsection}}

\lstdefinestyle{dmrsql}{
  language=SQL,
  basicstyle=\small\ttfamily,
  keywordstyle=\color{magenta!75!black},
  stringstyle=\color{green!50!black},
  showspaces=false,
  showstringspaces=false,
  commentstyle=\color{gray}}

\lstdefinestyle{dmrJava}{
  language=JAVA,
  basicstyle=\small\ttfamily,
  keywordstyle=\color{magenta!75!black},
  stringstyle=\color{green!50!black},
  showspaces=false,
  showstringspaces=false,
  commentstyle=\color{gray}}

\title{
  \textbf{\large Projektaufgabe 2 } \\
  Phase 1 – Legen der Basis (2.5 P) \\
  {\large Datenmanagement jenseits von Relationen}
}

\author{
  Gruppen Nummer (e.g. A1, B5, B3) \\
  \large Weilert Alexander, 12119653 \\
  \large Jovanovic Dragana, StudentID2
}

\begin{document}

\maketitle\thispagestyle{empty}

Dieses Reporting Template dient der Vorbereitung der Abgabe von Phase 1.

\subsection*{Datengenerator für Matrizen mit Sparsity (0.5 Punkte)}

Zeigen Sie den Code der Funktion generate() als Listing oder Screenshot.
Gehen Sie (kurz) auf die wesentlichen Aspekte ein.

Die generate(int l, double sparsity) Funktion wird mit einer Table_size l und sparsity aufgerufen. 
Zu Beginn werden die Tabllen A, B gelöscht und erstellt. Die View C wird nur gelöscht, da diese im Laufe des Codes generiert wird.
Weiters wird ein weiterer Aufruf auf die Funktion generateMatrixA (int l, double sparsity) und generateMatrixB(int l, double sparsity) ausgeführt, um das aufgefüllt Array für die Matrix zu generieren. 
generateMatrixA und generateMatrixB sind fast identisch, beide Funktionen vergleichen die Zahl Sparsity mit Math.random(),  ist der Wert kleiner wird der Matrix an der Stelle eine generierte Integer Zahl zwischen 1 und 11 hinzugefügt, andernfalls die Zahl 0.  
Die Unterschiede der Beiden Funktionen bauen sich nur auf dem Array auf. 
Im Code wird unser Array mit \enquoute{int[l-1][l] matrix} oder mit \enquoute{int[l][l-1] matrix} aufgerufen. Weiters werden auch die beiden for Schleifen miteinander vertauscht, so wird bei generateMatrixA auf \enquoute{i < l-1} abgeprüft und bei generateMatrixB auf \enquoute{j < l-1}.
Anschließend folgt ein weiter Aufruf auf insertMatrix(String tableName, int[][] matrix), welcher nichts anderes Macht, als die zuvor generierten Werte aus generateMatrix in das DBMS, mittels einem INSERT Befehls zu speichern.
Die letzten Aufruf ansatz0(int[][] matrixA, int[][] matrixB) und ansatz1() generieren beide auf Unterschiedliche Weise die Matrixmultiplikation für C. 
ansatz0 macht dies per Algorithmus und ansatz1 tut dies über eine selection auf a und b. 

\begin{lstlisting}[style=dmrJava]
  public void generate(int l, double sparsity) {
    try (Statement statement = this.connection.createStatement()) {
        statement.execute("DROP VIEW IF EXISTS C");
        statement.execute("DROP TABLE IF EXISTS A, B");
        // Create Table
        statement.execute("CREATE TABLE A (i int, j int, val int)");
        statement.execute("CREATE TABLE B (i int, j int, val int)");

        int[][] matrixA = generateMatrixA(l, sparsity);
        int[][] matrixB = generateMatrixB(l, sparsity);
        insertMatrix("A", matrixA);
        insertMatrix("B", matrixB);

        ansatz0(matrixA, matrixB); // Matrix Calculator per Algorithm
        ansatz1();                 // Matrix Calculator per Select

    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}

public int[][] generateMatrixA(int l, double sparsity) {
    Random random = new Random();
    int[][] matrixA = new int[l-1][l];
    System.out.println("--- Matrix A ---");
    for (int i = 0; i < ( l - 1 ); i++) {
        for (int j = 0; j < l; j++) {
            if (random.nextDouble() > sparsity) {
                matrixA[i][j] = random.nextInt(1, 11); // Random value between 0 and 10
            } else {
                matrixA[i][j] = 0;
            }
            System.out.print(matrixA[i][j] + " ");
        }
        System.out.println();
    }
    return matrixA;
}

public int[][] generateMatrixB(int l, double sparsity) {
    Random random = new Random();
    int[][] matrixB = new int[l][l-1];
    System.out.println("--- Matrix B ---");
    for (int i = 0; i < l; i++) {
        for (int j = 0; j < (l - 1); j++) {
            if (random.nextDouble() > sparsity) {
                matrixB[i][j] = random.nextInt(1, 11);// Random value between 0 and 10
            } else {
                matrixB[i][j] = 0;
            }
            System.out.print(matrixB[i][j] + " ");
        }
        System.out.println();
    }
    return matrixB;
}


public void insertMatrix(String tableName, int[][] matrix) {
    try (Statement statement = this.connection.createStatement()) {
        StringBuilder insertQuery = new StringBuilder("INSERT INTO " + tableName + " VALUES ");
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] != 0) {
                    insertQuery.append("(").append(i+1).append(",").append(j+1).append(",").append(matrix[i][j]).append("),");
                }
            }
        }
        insertQuery.deleteCharAt(insertQuery.length() - 1);
        statement.executeUpdate(insertQuery.toString());
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}
\end{lstlisting}

\subsection*{Import der Matrizen in das DBMS (0.5 Punkte)}

Geben Sie das Create Table Statement für Matrix $A$ an.

\begin{lstlisting}[style=dmrsql]
  CREATE TABLE A (i int, j int, val int)
\end{lstlisting}

Für die Übung bereiten Sie eine Demo des Datenimports vor.

Da der Import der Daten für die Matrix automatisch und zufällig passiert, muss mit den Daten gehandelt werden, die nun vorgerechnet werden. 
Mit der folgenden Seite, können Sie sich die Matrixmultiplikation berechnen lassen % Link oder Abändern. 


\subsection*{Wahl des Toy Beispiels (0.5 Punkte)}

Geben Sie Matrix $A$ und $B$ als 2D Array an.

% Neuen Screenshot reinwerfen
%\includegraphics{2D_Darstellung.jpg}

Zeigen Sie die äquivalente Darstellung der Matrix $A$ und $B$ in der Datenbank.

% Neuen Screenshot reinwerfen
%\includegraphics{table_a.jpg}
%\includegraphics{table_b.jpg}

\subsubsection*{Implementierung von Ansatz 0 (0.5 Punkte)}

Zeigen Sie den Code der Matrixmultiplikation als Listing oder Screenshot.
Erläutern Sie (kurz), welche Laufzeit ihr Algorithmus hat und warum das Kriterium keinen Algorithmus mit sub-kubischer Laufzeit zu wählen erfüllt ist.

\begin{lstlisting}[style=dmrJava]
    public void ansatz0(int[][] matrixA, int[][] matrixB) {
        try (Statement statement = this.connection.createStatement()) {
            statement.execute("DROP TABLE IF EXISTS matrix_algorithm");
            statement.execute("CREATE TABLE matrix_algorithm (i int, j int, val int)");
            StringBuilder insertQuery = new StringBuilder("INSERT INTO matrix_algorithm VALUES ");
            int[][] result = new int[matrixA.length][matrixB[0].length];
            System.out.println("--- Matrix Calculator ---");
            for (int i = 0; i < matrixA.length; i++) {
                for (int j = 0; j < matrixB[0].length; j++) {
                    for (int k = 0; k < matrixA[0].length; k++) {
                        result[i][j] += matrixA[i][k] * matrixB[k][j];
                    }
                insertQuery.append("(").append(i+1).append(",").append(j+1).append(",").append(result[i][j]).append("),");
                System.out.print(result[i][j] + " ");
                }
            System.out.println();
            }
            insertQuery.deleteCharAt(insertQuery.length() - 1);
            statement.executeUpdate(insertQuery.toString());
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
\end{lstlisting}

Der Algorithmus hat eine Laufzeit von O(n^3), da er drei verschiedene for-Schleifen durchläuft, die jeweils die länge l besitzen.
Für einen Algorithmus mit sub-kubischer Laufzeit müssen folgende Bedingungen erfüllt sein:


\subsubsection*{Implementierung von Ansatz 1 (0.5 Punkte)}
Berechnen Sie von Hand das Ergebnis $C = A \times B$ für ihr Toy Beispiel und geben Sie es nachfolgend an.

\begin{lstlisting}[style=dmrJava]
public void ansatz1() {
  try (Statement statement = this.connection.createStatement()) {
      statement.execute("CREATE VIEW C AS " +
          "SELECT a.i, b.j, SUM(A.val * B.val) " +
              "FROM a,  b " +
              "WHERE a.j = b.i " +
              "GROUP BY a.i, b.j");

      } catch (SQLException e) {
      throw new RuntimeException(e);
  }
}
\end{lstlisting}

Zeigen Sie, dass Ihr System $C$ korrekt berechnet (z.B. als Screenshot)

Wir nehmen an, dass das von Hand berechnete Ergebnis richtig bestimmt worden ist.
Vergleichen wir nun das von Hand berechnete, den Ansatz0 und den Ansatz1 so sehen wir eine Übereinstimmung aller Views, weswegen wir nun davon ausgehen können, das der Ansatz1 die Summe richtig berechnet.
% Screenshot reinwerfen
\includegraphics{}

\subsection*{Zeitmamagement}

Benötigte Zeit pro Person (nur Phase 1): \\ \\
\textbf{Alexander Weilert: 5h} \\
\textbf{Dragana Jovanovic: 5h}

\subsection*{References}

\begin{table}[H]
  \centering
  \begin{tabular}{c}
    \hline
    \textbf{Important:} Reference your information sources! \tabularnewline
    Remove this section if you use footnotes to reference your information sources.\tabularnewline
    \hline
  \end{tabular}
\end{table}

\end{document}
